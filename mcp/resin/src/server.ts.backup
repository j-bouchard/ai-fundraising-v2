/**
 * AI Fundraising MCP Server (Salesforce/NPSP)
 * - TypeScript MCP server exposing fundraising analytics and Salesforce write tools
 * - OAuth 2.0 refresh-token flow for Salesforce authentication
 * - NLP-to-SOQL parsing for donor segments
 *
 * This is a 1-to-1 refactor of the Python fundraising_mcp_server.py
 */
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import packageJson from "../package.json" with { type: "json" };

// ------------------------------------------------------------
// Constants & Configuration
// ------------------------------------------------------------
const DEFAULT_LIMIT = 25;
const CACHE_TTL_SECONDS = 60000; // Convert to milliseconds

// ------------------------------------------------------------
// Environment Variables (Cloudflare Workers bindings)
// ------------------------------------------------------------
// Note: In Cloudflare Workers, env vars are passed via the Env object
// This will be provided at runtime through the request handler

// ------------------------------------------------------------
// Types & Interfaces
// ------------------------------------------------------------
interface SalesforceConfig {
  clientId: string;
  clientSecret: string;
  refreshToken: string;
  instanceUrl: string;
  domain: string;
  username?: string;
  password?: string;
  securityToken?: string;
}

interface OAuthTokenResponse {
  access_token: string;
  instance_url: string;
}

interface SalesforceQueryResult {
  totalSize: number;
  done: boolean;
  records: any[];
}

interface SalesforceCreateResponse {
  id: string;
  success: boolean;
  errors: any[];
}

interface Timeframe {
  start: Date;
  end: Date;
}

// ------------------------------------------------------------
// Utility Functions: Formatting & Parsing
// ------------------------------------------------------------
function fmtCurrency(amount: number | null | undefined): string {
  if (amount == null) return "$0.00";
  return `$${amount.toLocaleString("en-US", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  })}`;
}

function fmtDate(dt: Date | string | null | undefined): string {
  if (!dt) return "";
  const date = typeof dt === "string" ? new Date(dt) : dt;
  return date.toISOString().split("T")[0];
}

function header(title: string): string {
  return `${title}\n${"-".repeat(Math.max(6, title.length))}`;
}

// Amount parsing patterns
const AMOUNT_PATTERN =
  /\$?\s*(\d{1,3}(?:[,\s]\d{3})*(?:\.\d{1,2})?|\d+(?:\.\d{1,2})?|\d+\s*[kKmMbB])/;
const MONTHS_PATTERN = /(last|past)\s*(\d+)\s*(month|months)/i;
const YEARS_PATTERN = /(last|past)\s*(\d+)\s*(year|years)/i;
const SIX_MONTHS_PATTERN = /(last|past)\s*6\s*months/i;
const ONE_YEAR_PATTERN = /(last|past)\s*1\s*year/i;

function parseAmount(text: string): number | null {
  const match = text.replace(/,/g, "").match(AMOUNT_PATTERN);
  if (!match) return null;

  let raw = match[1].trim().toLowerCase();
  let factor = 1;

  if (raw.endsWith("k")) {
    factor = 1000;
    raw = raw.slice(0, -1);
  } else if (raw.endsWith("m")) {
    factor = 1000000;
    raw = raw.slice(0, -1);
  } else if (raw.endsWith("b")) {
    factor = 1000000000;
    raw = raw.slice(0, -1);
  }

  try {
    return parseFloat(raw) * factor;
  } catch {
    return null;
  }
}

function parseTimeframe(text: string): Timeframe | null {
  const now = new Date();

  // Check for months pattern
  let match = text.match(MONTHS_PATTERN);
  if (match) {
    const months = parseInt(match[2], 10);
    const start = new Date(now);
    start.setMonth(start.getMonth() - months);
    return { start, end: now };
  }

  // Check for years pattern
  match = text.match(YEARS_PATTERN);
  if (match) {
    const years = parseInt(match[2], 10);
    const start = new Date(now);
    start.setFullYear(start.getFullYear() - years);
    return { start, end: now };
  }

  // Check for specific patterns
  if (SIX_MONTHS_PATTERN.test(text)) {
    const start = new Date(now);
    start.setMonth(start.getMonth() - 6);
    return { start, end: now };
  }

  if (ONE_YEAR_PATTERN.test(text)) {
    const start = new Date(now);
    start.setFullYear(start.getFullYear() - 1);
    return { start, end: now };
  }

  return null;
}

// ------------------------------------------------------------
// Salesforce OAuth Client
// ------------------------------------------------------------
class SalesforceAuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "SalesforceAuthError";
  }
}

class SalesforceClient {
  private config: SalesforceConfig;
  private accessToken: string | null = null;
  private cache: Map<string, { data: any; timestamp: number }> = new Map();

  constructor(config: SalesforceConfig) {
    this.config = config;
  }

  private getTokenEndpoint(): string {
    const base =
      this.config.domain === "login"
        ? "https://login.salesforce.com"
        : "https://test.salesforce.com";
    return `${base}/services/oauth2/token`;
  }

  private async refreshAccessToken(): Promise<{
    accessToken: string;
    instanceUrl: string;
  }> {
    if (
      !this.config.clientId ||
      !this.config.clientSecret ||
      !this.config.refreshToken
    ) {
      throw new SalesforceAuthError(
        "Missing OAuth env vars: SF_CLIENT_ID/SF_CLIENT_SECRET/SF_REFRESH_TOKEN",
      );
    }

    const params = new URLSearchParams({
      grant_type: "refresh_token",
      client_id: this.config.clientId,
      client_secret: this.config.clientSecret,
      refresh_token: this.config.refreshToken,
    });

    const response = await fetch(this.getTokenEndpoint(), {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: params,
    });

    if (!response.ok) {
      const text = await response.text();
      throw new SalesforceAuthError(
        `OAuth refresh failed: ${response.status} ${text}`,
      );
    }

    const data: OAuthTokenResponse = await response.json();

    if (!data.access_token || !data.instance_url) {
      throw new SalesforceAuthError(
        "OAuth refresh succeeded but missing access_token/instance_url",
      );
    }

    return {
      accessToken: data.access_token,
      instanceUrl: data.instance_url,
    };
  }

  async connect(): Promise<void> {
    try {
      const { accessToken, instanceUrl } = await this.refreshAccessToken();
      this.accessToken = accessToken;
      this.config.instanceUrl = instanceUrl;
      console.log("Connected to Salesforce");
    } catch (error) {
      console.warn(
        "OAuth refresh failed, attempting username/password if provided:",
        error,
      );
      if (
        !this.config.username ||
        !this.config.password ||
        !this.config.securityToken
      ) {
        throw error;
      }
      // Username/password flow not implemented in this version
      // Would require additional Salesforce SOAP API integration
      throw new Error("Username/password flow not implemented");
    }
  }

  private getCachedData(key: string): any | null {
    const cached = this.cache.get(key);
    if (!cached) return null;

    const age = Date.now() - cached.timestamp;
    if (age > CACHE_TTL_SECONDS) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  private setCachedData(key: string, data: any): void {
    this.cache.set(key, { data, timestamp: Date.now() });
  }

  async soql(query: string): Promise<SalesforceQueryResult> {
    if (!this.accessToken) {
      await this.connect();
    }

    const cacheKey = `soql:${query}`;
    const cached = this.getCachedData(cacheKey);
    if (cached) return cached;

    const url = `${this.config.instanceUrl}/services/data/v60.0/query?q=${encodeURIComponent(query)}`;
    const response = await fetch(url, {
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`SOQL query failed: ${response.status} ${text}`);
    }

    const result = (await response.json()) as SalesforceQueryResult;
    this.setCachedData(cacheKey, result);
    return result;
  }

  async create(
    sobject: string,
    data: Record<string, any>,
  ): Promise<SalesforceCreateResponse> {
    if (!this.accessToken) {
      await this.connect();
    }

    const url = `${this.config.instanceUrl}/services/data/v60.0/sobjects/${sobject}`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(
        `Salesforce create failed: ${response.status} ${text}`,
      );
    }

    return response.json();
  }

  async update(
    sobject: string,
    recordId: string,
    data: Record<string, any>,
  ): Promise<void> {
    if (!this.accessToken) {
      await this.connect();
    }

    const url = `${this.config.instanceUrl}/services/data/v60.0/sobjects/${sobject}/${recordId}`;
    const response = await fetch(url, {
      method: "PATCH",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(
        `Salesforce update failed: ${response.status} ${text}`,
      );
    }
  }
}

// ------------------------------------------------------------
// SOQL Builder for Donor Segments
// ------------------------------------------------------------
class SOQLBuilder {
  static lapsedDonors(months: number = 12, limit: number = DEFAULT_LIMIT): string {
    const days = months * 30;
    return `SELECT Id, Name, Email, ` +
      `(SELECT SUM(Amount) total FROM Opportunities WHERE IsWon=true) LifetimeGiving, ` +
      `(SELECT MAX(CloseDate) lastGiftDate FROM Opportunities WHERE IsWon=true) LastGiftDate ` +
      `FROM Contact ` +
      `WHERE Id IN (SELECT ContactId FROM OpportunityContactRole WHERE Opportunity.IsWon=true) ` +
      `AND Id NOT IN (SELECT ContactId FROM OpportunityContactRole WHERE Opportunity.IsWon=true AND Opportunity.CloseDate = LAST_N_DAYS:${days}) ` +
      `LIMIT ${limit}`;
  }

  static majorDonorsOver(amount: number, limit: number = DEFAULT_LIMIT): string {
    return `SELECT Id, Name, Email, ` +
      `(SELECT SUM(Amount) total FROM Opportunities WHERE IsWon=true) LifetimeGiving ` +
      `FROM Contact ` +
      `WHERE Id IN (SELECT ContactId FROM OpportunityContactRole WHERE Opportunity.IsWon=true) ` +
      `AND Id IN (SELECT ContactId FROM OpportunityContactRole WHERE Opportunity.IsWon=true GROUP BY ContactId HAVING SUM(Opportunity.Amount) > ${Math.floor(amount)}) ` +
      `LIMIT ${limit}`;
  }

  static recentDonorsLastNMonths(months: number, limit: number = DEFAULT_LIMIT): string {
    const days = Math.max(1, months * 30);
    return `SELECT Id, Name, Email, ` +
      `(SELECT MAX(CloseDate) lastGiftDate FROM Opportunities WHERE IsWon=true AND CloseDate = LAST_N_DAYS:${days}) LastGiftDate ` +
      `FROM Contact WHERE Id IN (SELECT ContactId FROM OpportunityContactRole WHERE ` +
      `Opportunity.IsWon=true AND Opportunity.CloseDate = LAST_N_DAYS:${days}) ` +
      `LIMIT ${limit}`;
  }

  static firstTimeDonors(limit: number = DEFAULT_LIMIT): string {
    return `SELECT Id, Name, Email FROM Contact WHERE ` +
      `Id IN (SELECT ContactId FROM OpportunityContactRole WHERE Opportunity.IsWon=true GROUP BY ContactId HAVING COUNT(Opportunity.Id) = 1) ` +
      `LIMIT ${limit}`;
  }
}

function buildSoqlFromCriteria(
  criteria: string,
  limit: number = DEFAULT_LIMIT,
): { soql: string; meta: Record<string, any> } {
  const text = criteria.toLowerCase().trim();
  const meta: Record<string, any> = { limit };

  if (text.includes("lapsed")) {
    let months = 12;
    const tf = parseTimeframe(text);
    if (tf) {
      const daysDiff = Math.floor(
        (Date.now() - tf.start.getTime()) / (1000 * 60 * 60 * 24),
      );
      months = Math.max(1, Math.floor(daysDiff / 30));
    }
    meta.segment = "lapsed_donors";
    meta.months = months;
    return { soql: SOQLBuilder.lapsedDonors(months, limit), meta };
  }

  if (text.includes("major") || text.includes("over") || text.includes("$")) {
    const amt = parseAmount(text) || 1000.0;
    meta.segment = "major_donors_over";
    meta.amount = amt;
    return { soql: SOQLBuilder.majorDonorsOver(amt, limit), meta };
  }

  if (text.includes("recent") && text.includes("month")) {
    let months = 6;
    const tf = parseTimeframe(text);
    if (tf) {
      const daysDiff = Math.floor(
        (Date.now() - tf.start.getTime()) / (1000 * 60 * 60 * 24),
      );
      months = Math.max(1, Math.floor(daysDiff / 30));
    }
    meta.segment = "recent_donors";
    meta.months = months;
    return { soql: SOQLBuilder.recentDonorsLastNMonths(months, limit), meta };
  }

  if (text.includes("first")) {
    meta.segment = "first_time_donors";
    return { soql: SOQLBuilder.firstTimeDonors(limit), meta };
  }

  // Default: recent donors 6 months
  meta.segment = "recent_donors";
  meta.months = 6;
  meta.defaulted = true;
  return { soql: SOQLBuilder.recentDonorsLastNMonths(6, limit), meta };
}

// ------------------------------------------------------------
// NL to SOQL (general router)
// ------------------------------------------------------------
function nlToSoql(
  question: string,
  defaultLimit: number = DEFAULT_LIMIT,
): { soql: string; explanation: string } {
  const q = question.toLowerCase().trim();

  // How many donations this month?
  if (/how\s+many\s+(donation|gift)s?.*this\s+month/.test(q)) {
    return {
      soql: "SELECT COUNT() FROM Opportunity WHERE IsWon = true AND CloseDate = THIS_MONTH",
      explanation: "Count of won opportunities in the current month",
    };
  }

  // Top N donors this quarter
  const topMatch = q.match(/top\s+(\d+)\s+donor/);
  const topN = topMatch ? parseInt(topMatch[1], 10) : 10;
  if (
    q.includes("top") &&
    q.includes("donor") &&
    (q.includes("quarter") || q.includes("this quarter"))
  ) {
    return {
      soql:
        `SELECT ContactId, SUM(Opportunity.Amount) total ` +
        `FROM OpportunityContactRole ` +
        `WHERE Opportunity.IsWon = true AND Opportunity.CloseDate = THIS_QUARTER ` +
        `GROUP BY ContactId ORDER BY SUM(Opportunity.Amount) DESC ` +
        `LIMIT ${topN}`,
      explanation: "Top donors this quarter by total won amount",
    };
  }

  // Last year but not this year
  if (
    (q.includes("last year") || q.includes("this time last year")) &&
    (q.includes("hasn't given since") ||
      q.includes("not since") ||
      q.includes("haven't given since"))
  ) {
    return {
      soql:
        `SELECT Id, Name, Email FROM Contact WHERE Id IN (` +
        `SELECT ContactId FROM OpportunityContactRole WHERE Opportunity.IsWon=true AND Opportunity.CloseDate = LAST_YEAR) ` +
        `AND Id NOT IN (SELECT ContactId FROM OpportunityContactRole WHERE Opportunity.IsWon=true AND Opportunity.CloseDate = THIS_YEAR) ` +
        `LIMIT ${defaultLimit}`,
      explanation: "Contacts who gave last year but not yet this year",
    };
  }

  // Recent donors N months
  const monthsMatch = q.match(/last\s*(\d+)\s*months?/);
  if ((q.includes("donor") || q.includes("gift")) && monthsMatch) {
    const months = Math.max(1, parseInt(monthsMatch[1], 10));
    return {
      soql: SOQLBuilder.recentDonorsLastNMonths(months, defaultLimit),
      explanation: `Contacts with gifts in the last ${months} months`,
    };
  }

  // Fallback
  return {
    soql: SOQLBuilder.recentDonorsLastNMonths(6, defaultLimit),
    explanation: "Fallback: recent donors in the last 6 months",
  };
}

// ------------------------------------------------------------
// Fundraising Server Implementation
// ------------------------------------------------------------
class FundraisingServer {
  private sf: SalesforceClient;

  constructor(env: Record<string, string>) {
    const config: SalesforceConfig = {
      clientId: env.SF_CLIENT_ID || "",
      clientSecret: env.SF_CLIENT_SECRET || "",
      refreshToken: env.SF_REFRESH_TOKEN || "",
      instanceUrl: env.SF_INSTANCE_URL || "",
      domain: env.SF_DOMAIN || "login",
      username: env.SF_USERNAME,
      password: env.SF_PASSWORD,
      securityToken: env.SF_SECURITY_TOKEN,
    };
    this.sf = new SalesforceClient(config);
  }

  private async ensureConnected(): Promise<void> {
    if (!this.sf) {
      throw new Error("Salesforce client not initialized");
    }
    // Connection will happen lazily on first API call
  }

  private formatRecords(
    title: string,
    records: any[],
    insights: string[],
    nextSteps: string[],
  ): string {
    const lines: string[] = [header(title)];

    for (const r of records) {
      const name = r.Name || r.Contact?.Name || "Unknown";
      const email = r.Email || "";
      const total =
        r.LifetimeGiving || r.total || r.attributes?.total;
      const last = r.LastGiftDate || r.lastGiftDate;

      lines.push(`- Name: ${name}`);
      if (email) lines.push(`  - Email: ${email}`);
      if (total !== undefined) {
        lines.push(`  - Lifetime Giving: ${fmtCurrency(parseFloat(total))}`);
      }
      if (last) {
        lines.push(`  - Last Gift: ${fmtDate(last)}`);
      }
    }

    if (insights.length > 0) {
      lines.push("");
      lines.push(header("AI Insights"));
      lines.push(...insights.map((i) => `- ${i}`));
    }

    if (nextSteps.length > 0) {
      lines.push("");
      lines.push(header("Next Steps"));
      lines.push(...nextSteps.map((n) => `- ${n}`));
    }

    return lines.join("\n");
  }

  async toolRunSoql(query: string, limit: number = DEFAULT_LIMIT): Promise<string> {
    await this.ensureConnected();
    const q = query.trim();

    try {
      const res = await this.sf.soql(q);

      // Special case for COUNT()
      if (
        res.records.length === 0 &&
        res.totalSize !== undefined &&
        q.toLowerCase().startsWith("select count")
      ) {
        return (
          header("SOQL Count Result") +
          `\n- Count: ${res.totalSize}\n- Query: \`${q}\``
        );
      }

      // Truncate for display
      const records = res.records.slice(0, limit);
      return (
        header("SOQL Result") +
        `\n- Records returned: ${records.length} of ${res.totalSize}\n- Query: \`${q}\`\n\n` +
        JSON.stringify(records, null, 2)
      );
    } catch (error: any) {
      return (
        header("Salesforce Error") +
        `\n- Unable to run SOQL. ${error.message}\n- Query: \`${q}\``
      );
    }
  }

  async toolCreateRecord(
    sobject: string,
    fields: Record<string, any>,
  ): Promise<string> {
    await this.ensureConnected();

    if (!sobject || !fields || Object.keys(fields).length === 0) {
      return (
        header("Validation Error") +
        "\n- Provide sobject (string) and fields (non-empty object)."
      );
    }

    try {
      const res = await this.sf.create(sobject, fields);
      return (
        header("Record Created") +
        `\n- sObject: ${sobject}\n- Id: ${res.id}\n- Fields: ${JSON.stringify(fields)}`
      );
    } catch (error: any) {
      return (
        header("Salesforce Error") +
        `\n- Unable to create ${sobject}. ${error.message}`
      );
    }
  }

  async toolUpdateRecord(
    sobject: string,
    recordId: string,
    fields: Record<string, any>,
  ): Promise<string> {
    await this.ensureConnected();

    if (!sobject || !recordId || !fields || Object.keys(fields).length === 0) {
      return (
        header("Validation Error") +
        "\n- Provide sobject, record_id, and fields (non-empty object)."
      );
    }

    try {
      await this.sf.update(sobject, recordId, fields);
      return (
        header("Record Updated") +
        `\n- sObject: ${sobject}\n- Id: ${recordId}\n- Fields: ${JSON.stringify(fields)}`
      );
    } catch (error: any) {
      return (
        header("Salesforce Error") +
        `\n- Unable to update ${sobject} ${recordId}. ${error.message}`
      );
    }
  }
}

// ------------------------------------------------------------
// MCP Server Setup Factory
// ------------------------------------------------------------
export function createServer(env: Record<string, string>) {
  const server = new McpServer({
    title: "AI Fundraising (Salesforce/NPSP)",
    name: packageJson.name,
    version: packageJson.version,
  });

  const fundraisingServer = new FundraisingServer(env);

  // Register the three main tools
  server.registerTool(
    "run_soql",
    {
      title: "Run SOQL Query",
      description:
        "Execute a SOQL query against Salesforce. Returns formatted results with record count. Supports all standard SOQL features including COUNT(), aggregations, and subqueries.",
      inputSchema: {
        query: z.string().describe("The SOQL query to execute"),
        limit: z
          .number()
          .int()
          .min(1)
          .max(100)
          .default(DEFAULT_LIMIT)
          .optional()
          .describe("Maximum number of records to return in display"),
      },
    },
    async ({ query, limit }) => {
      const result = await fundraisingServer.toolRunSoql(
        query,
        limit || DEFAULT_LIMIT,
      );
      return {
        content: [{ type: "text" as const, text: result }],
      };
    },
  );

  server.registerTool(
    "create_record",
    {
      title: "Create Salesforce Record",
      description:
        "Create any Salesforce sObject record (Contact, Opportunity, Task, etc.). Provide the sObject type and field values. Returns the created record ID.",
      inputSchema: {
        sobject: z
          .string()
          .describe("The sObject type (e.g., Contact, Opportunity, Task)"),
        fields: z
          .record(z.any())
          .describe("Field names and values for the new record"),
      },
    },
    async ({ sobject, fields }) => {
      const result = await fundraisingServer.toolCreateRecord(sobject, fields);
      return {
        content: [{ type: "text" as const, text: result }],
      };
    },
  );

  server.registerTool(
    "update_record",
    {
      title: "Update Salesforce Record",
      description:
        "Update any Salesforce sObject record by ID. Provide the sObject type, record ID, and fields to update.",
      inputSchema: {
        sobject: z
          .string()
          .describe("The sObject type (e.g., Contact, Opportunity, Task)"),
        record_id: z.string().describe("The 15 or 18 character Salesforce record ID"),
        fields: z
          .record(z.any())
          .describe("Field names and new values to update"),
      },
    },
    async ({ sobject, record_id, fields }) => {
      const result = await fundraisingServer.toolUpdateRecord(
        sobject,
        record_id,
        fields,
      );
      return {
        content: [{ type: "text" as const, text: result }],
      };
    },
  );

  return server;
}

// Default export for backwards compatibility
export default createServer({});
